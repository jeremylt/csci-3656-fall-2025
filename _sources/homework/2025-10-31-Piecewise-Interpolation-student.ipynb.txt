{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "a6724dc6-feaf-4eae-8a6e-1d20cc769fcd",
   "metadata": {},
   "source": [
    "Before you turn this problem in, make sure everything runs as expected.\n",
    "First, restart the kernel (in the menubar, select Kernel → Restart) and then run all cells (in the menubar, select Cell → Run All).\n",
    "\n",
    "Make sure you fill in any place that says `BEGIN SOLUTION` and `END SOLUTION`, as well as your name and collaborators below:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "edb2e18f-4212-42fc-a752-6974b5667fce",
   "metadata": {},
   "outputs": [],
   "source": [
    "NAME = \"\"\n",
    "COLLABORATORS = \"\""
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dc711929-d438-45ec-a8e6-e11bf1f008d4",
   "metadata": {},
   "source": [
    "# 2025-10-31 Piecewise Interpolation\n",
    "\n",
    "We covered global polynomial interpolation, piecwise constant interpolation, and piecewise spline interpolation.\n",
    "In this assignment, we will explore piecewise polynomial interpolation with each piece being a polynomial of degree three or higher.\n",
    "We will then use these piecewise polynomials for interpolation.\n",
    "\n",
    "To start, we will use our matrix for polynomial interpolation with Chebyshev polynomials from class.\n",
    "The Chebyshev polynomials can be generated with the recursion\n",
    "\n",
    "$$ \\begin{align}\n",
    "   T_0 \\left( x \\right) &= 1\\\\\n",
    "   T_1 \\left( x \\right) &= x\\\\\n",
    "   T_n \\left( x \\right) &= 2 x T_{n - 1} \\left( x \\right) - T_{n - 2}\n",
    "\\end{align} $$\n",
    "\n",
    "and our interpolating polynomial is given by $p \\left( x \\right) = \\sum_{i = 0}^{k-1} c_i T_i \\left( x \\right)$, where $k$ is the number of interpolation points and $k - 1$ is the highest order (degree) of our Chebyshev polynomials.\n",
    "\n",
    "Recall that with this Vandermonde matrix for the Chebyshev polynomials, we create a matrix equation $A c = p$, where $A$ is the Vandermonde matrix with columns given by the Chebyshev polynomials $T_i \\left( x \\right)$ and the rows given by our interpolation points $x_j$, $c$ is the vector of coefficients for each individual Chebyshev polynomial, and $p$ is the values of our interpolating polynomial $p \\left( x \\right)$ at our interpolation points $x_j$.\n",
    "\n",
    "## Fitting on one interval"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "804408a0-abe0-4df2-bf4e-a78df49c8916",
   "metadata": {},
   "outputs": [],
   "source": [
    "using LinearAlgebra\n",
    "using Plots\n",
    "using Test\n",
    "\n",
    "# Our Vandermonde matrix for Chebyshev polynomials\n",
    "function vander_chebyshev(x, k=nothing)\n",
    "    \"\"\"Return a Vandermonde matrix of the first n Chebyshev polynomials evaluated at the points x.\n",
    "    The returned matrix will be of size n x k, where n is the length of the vector x.\n",
    "    If no k is provided, the returned matrix will be square.\n",
    "    \"\"\"\n",
    "    if isnothing(k)\n",
    "        k = length(x)\n",
    "    end\n",
    "    n = length(x)\n",
    "    A = ones(n, k)\n",
    "    A[:, 2] = x\n",
    "    for i in 3:k\n",
    "        A[:, i] = 2 * x .* A[:, i-1] - A[:, i-2]\n",
    "    end\n",
    "    A\n",
    "end\n",
    "\n",
    "# Let's try it\n",
    "k = 4\n",
    "A = vander_chebyshev(Vector(LinRange(-1, 1, k)))\n",
    "println(\"A =\")\n",
    "display(A);"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9a7a3076-eaf4-458d-a8c9-09bf3e81632e",
   "metadata": {},
   "source": [
    "We'll solve a small interpolation problem to make sure this function works as expected."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5087e633-063b-4acf-a354-6abe9ddbbcc5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# The target function\n",
    "k = 5\n",
    "x = LinRange(-1, 1, k)\n",
    "y = sin.(x)\n",
    "\n",
    "# The Vandermonde matrix\n",
    "A = vander_chebyshev(x)\n",
    "\n",
    "# Solve for the coefficents\n",
    "c = inv(A) * y\n",
    "\n",
    "# And use the coefficients\n",
    "scatter(x, y, label=\"data\")\n",
    "x = LinRange(-1, 1, 100)\n",
    "p = vander_chebyshev(x, k) * c\n",
    "plot!(x, p, label=\"fit\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4afa53ed-fcdb-4609-b317-d1124b9d39dd",
   "metadata": {},
   "source": [
    "## Fitting on multiple subintervals\n",
    "\n",
    "We can now use this Vandermonde matrix to fix polynomials piecewise.\n",
    "\n",
    "Consider the interval from $\\left[ -1, 3 \\right]$.\n",
    "We can divide this into two sub-intervals, $\\left[ -1, 1 \\right]$ and $\\left[ 1, 3 \\right]$ and fit a polynomial of degree $k$ to each subinterval via our Vandermonde matrix.\n",
    "We will have separate sets of coefficients $c_{0, i}$ and $c_{1, i}$ such that\n",
    "\n",
    "$$ p_0 \\left( x \\right) = \\sum_{i = 0}^{k-1} c_{0, i} T_i \\left( x \\right), x \\in \\left[ -1, 1 \\right] $$\n",
    "\n",
    "and\n",
    "\n",
    "$$ p_1 \\left( x \\right) = \\sum_{i = 0}^{k-1} c_{1, i} T_i \\left( x - 2 \\right) , x \\in \\left[ 1, 3 \\right] $$\n",
    "\n",
    "For simplicity, we'll use a small 'trick'.\n",
    "Instead of creating a new Vandermonde matrix for each subinterval, we'll just reuse the same Vandermonde matrix on the interval $\\left[ -1, 1 \\right]$ and fit two separate sets of coefficients.\n",
    "When evaluating these polynomials, we'll shift the input $x$ back into the range $\\left[ -1, 1 \\right]$ for the current piecewise piece of our polynomial fit."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "520b6a72-121b-4b89-9f47-193d551c3270",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Our first range\n",
    "k = 5\n",
    "x1 = LinRange(-1, 1, k)\n",
    "y1 = sin.(x1)\n",
    "scatter(x1, y1, label=\"data, subinterval 1\")\n",
    "\n",
    "# The first fit\n",
    "A = vander_chebyshev(x1)\n",
    "A_inv = inv(A)\n",
    "@show c1 = A_inv * y1\n",
    "x = LinRange(-1, 1, 100)\n",
    "plot!(x, vander_chebyshev(x, k) *  c1, label=\"fit, subinterval 1\")\n",
    "\n",
    "# Our second range\n",
    "x2 = LinRange(1, 3, k)\n",
    "y2 = sin.(x2)\n",
    "scatter!(x2, y2, label=\"data, subinterval 2\")\n",
    "\n",
    "# The second fit\n",
    "@show c2 = A_inv * y2\n",
    "x = LinRange(-1, 1, 100)\n",
    "plot!(x .+ 2, vander_chebyshev(x, k) * c2, label=\"fit, subinterval 2\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2a3db8a5-96e5-4466-9953-cb7d21cdf599",
   "metadata": {},
   "source": [
    "We could create a single large matrix equation representing this computation, but that matrix would have multiple copies of our Vandermonde matrix, which would be inefficient.\n",
    "Let's instead make a single function that solves these systems of equations for each piece of our piecewise polynomial."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c866dfd7-a169-4f60-8655-47e8216cb67e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Fit piecewise Chebyshev polynomials\n",
    "function fit_piecewise_chebyshev(x, y, n, k)\n",
    "    \"\"\"Return the polynomial coefficents for a piecewise fit of Chebyshev polynomials\n",
    "    at the points x with the values f(x_i) = y_i. on subintervals of length w.\n",
    "    The parameter n is the number of subintervals.\n",
    "    The parameter k is the number of points in each subinterval.\n",
    "    The subinterval length is given by (x[end] - x[1]) / n.\n",
    "    This function returns (a, C), where a is the start of the first subinterval, and C\n",
    "    is a list of sets of Chebyshev coefficients, where C_j corresponds to the interval\n",
    "    [a + w*(j - 1), a + w*j].\n",
    "    \"\"\"\n",
    "    # Get dimensions\n",
    "    a = x[1]\n",
    "    w = (x[end] - x[1]) / n # length of a subinterval\n",
    "    # Build our Vandermonde matrix\n",
    "    A = vander_chebyshev((x[1:k] .- a) .* (2 / w) .- 1) # Why this \".- a) .* (2 / w) .- 1\" part?\n",
    "    A_inv = inv(A)\n",
    "    # And a place to hold coefficients\n",
    "    C = []\n",
    "    for j in 1:n\n",
    "        # Now solve for the current set of coeffients for the current subset of y\n",
    "        yj = zeros(k) # What is the correct indices from y?\n",
    "        ### BEGIN SOLUTION\n",
    "\n",
    "        ### END SOLUTION\n",
    "        push!(C, c)\n",
    "    end\n",
    "    a, C\n",
    "end\n",
    "\n",
    "# Let's make the same data combined\n",
    "k = 5\n",
    "n = 2\n",
    "x = LinRange(-1, -1 + 2*n, n*(k-1) + 1)\n",
    "y = sin.(x)\n",
    "p = scatter(x, y, label=\"data\")\n",
    "display(p)\n",
    "\n",
    "# And let's try to fit our piecewise polynomial\n",
    "a, C = fit_piecewise_chebyshev(x, y, n, k)\n",
    "@show C;"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "853f5177-e54e-47cd-aca4-419da06258a8",
   "metadata": {},
   "outputs": [],
   "source": [
    "k = 5\n",
    "n = 5\n",
    "x = LinRange(1, 1 + n*2, n*(k-1) + 1)\n",
    "y = cos.(x) .* log.(x)\n",
    "a, C = fit_piecewise_chebyshev(x, y, n, k)\n",
    "\n",
    "@test a == 1\n",
    "@test length(C) == 5\n",
    "@test C[1] ≈ [-0.4164026546438594, -0.6167932864672474, -0.12767897738782175, 0.07298432524001167, 0.00027267080444547744]\n",
    "@test C[2] ≈ [-0.6019173600399995, 0.8000865534138122, 0.29530092118109597, -0.028009254382361723, -0.008924184564117534]\n",
    "@test C[3] ≈ [1.332621217129435, 0.5434549235122322, -0.379306420655918, -0.038210237255288715, 0.00846656539185615]\n",
    "@test C[4] ≈ [-0.2857915440827067, -1.8185885681934457, 0.017546468197354503, 0.08409664184838822, 0.000779197662611586]\n",
    "@test C[5] ≈ [-1.4529213285142264, 1.0464432985128442, 0.4681804363327252, -0.040158216086755155, -0.01093182996020823]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "94541338-c1dd-4ce1-b7fb-a65979c3041c",
   "metadata": {},
   "source": [
    "## Applying our fit\n",
    "\n",
    "Naturally, having the sets of polynomial coefficients is not very useful if we cannot use them.\n",
    "Now we need a function to apply our coefficients to produce values at a given set of points, $x$.\n",
    "\n",
    "In this function, we will assume that the subintervals overlap.\n",
    "That means that if we have 3 subintervals with 5 points each, then\n",
    "\n",
    "* subinterval 1 contains points 1, 2, 3, 4, and 5\n",
    "* subinterval 2 contains points 5, 6, 7, 9, and 9\n",
    "* subinterval 3 contains points 9, 10, 11, 12, and 13\n",
    "\n",
    "These subintervals overlap, so we will have an 'extra' point on each subinterval.\n",
    "\n",
    "We will call the number of points we are providing interpolated values for $k_\\text{interp}$ while we call the number of original points we fit against $k_\\text{fit}$.\n",
    "Thus, we will use a Vandermonde matrix of size $k_\\text{interp} \\times k_\\text{fit}$ to compute the interpolated values $y_i$ on each subinterval.\n",
    "\n",
    "We will therefore compute\n",
    "\n",
    "$$ p_j \\left( x \\right) = \\sum_{i = 0}^{k-1} c_{j, i} T_i \\left( \\left( x - \\left( a + w \\left( j - 1 \\right) \\right) \\right) \\left( 2 / w \\right) - 1 \\right) $$\n",
    "\n",
    "for subintervals $j \\in \\left\\lbrace 1, 2, \\dots \\right\\rbrace$ and $w$ is the width of the subintervals.\n",
    "\n",
    "Notice that like above, we shift and rescale the values of $x$ for each subinterval $j$ so that $\\left[ a + w \\left( j - 1 \\right), a + w j \\right]$ becomes $\\left[ -1, 1 \\right]$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "871bb2ce-af5f-4873-893d-eb0183a16f56",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Interpolate piecewise Chebyshev polynomials\n",
    "function interpolate_piecewise_chebyshev(x, a, C, n, k_interp)\n",
    "    \"\"\"Return the interpolation from a piecewise fit of Chebyshev polynomials on the interval x.\n",
    "    n is a parameter sating how many subintervals there are.\n",
    "    k_interp is a parameter stating how many points are on each subinterval.\n",
    "    The width of the subintervals is therefore (x[end] - x[1]) / n.\n",
    "    This function returns y, where a is the start of the first sub interval, and C\n",
    "    is a list of sets of Chebyshev coefficients, where C_i corresponds to the interval\n",
    "    [a + 2*(i - 1), a + 2*i].\n",
    "    \"\"\"\n",
    "    # Get dimensions\n",
    "    k_fit = length(C[1])\n",
    "    @assert length(C) == n # these need to match\n",
    "    w = (x[end] - x[1]) / n\n",
    "    # Build our Vandermonde matrix\n",
    "    A = vander_chebyshev((x[1:k_interp] .- a) .* (2 / w) .- 1, k_fit)\n",
    "    # And a place to hold output\n",
    "    y = zeros(length(x))\n",
    "    for j in 1:n\n",
    "        # Now solve for the current set of coeffients for the current subset of y\n",
    "        yj = zeros(k_interp)\n",
    "        ### BEGIN SOLUTION\n",
    "\n",
    "        ### END SOLUTION\n",
    "        y[1 + (j - 1)*(k_interp - 1) : 1 + j*(k_interp - 1)] = yj\n",
    "    end\n",
    "    y\n",
    "end\n",
    "\n",
    "# Let's make the same data combined\n",
    "k = 5\n",
    "n = 2\n",
    "x = LinRange(-1, -1 + 2*n, n*(k-1) + 1)\n",
    "y = sin.(x)\n",
    "scatter(x, y, label=\"data\")\n",
    "\n",
    "# And let's try to fit our piecewise polynomial\n",
    "a, C = fit_piecewise_chebyshev(x, y, n, k)\n",
    "\n",
    "# Finally, let's use that fit\n",
    "k = 50\n",
    "x = LinRange(-1, 3, 2*(k-1) + 1)\n",
    "y = interpolate_piecewise_chebyshev(x, a, C, n, k)\n",
    "p = plot!(x, y, label=\"fit\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b4512c8d-46e0-4aff-83c6-8bb1998c5787",
   "metadata": {},
   "outputs": [],
   "source": [
    "k = 4\n",
    "n = 2\n",
    "x = LinRange(-1, -1+2*n, n*(k-1) + 1)\n",
    "y = x.^3\n",
    "a, C = fit_piecewise_chebyshev(x, y, n, k)\n",
    "\n",
    "k = 50\n",
    "x = LinRange(-1, -1+2*n, n*(k-1) + 1)\n",
    "y = interpolate_piecewise_chebyshev(x, a, C, n, k)\n",
    "@test y ≈ x.^3"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e5a0e8c4-a94c-48d2-9a7a-a1d651f4ad0d",
   "metadata": {},
   "source": [
    "## Runge returns\n",
    "\n",
    "Now let's compare a fit with a piecewise polynomial to a single global polynomial.\n",
    "\n",
    "You should notice that the Runge phenomenon is less pronounced but still present for each piece of the piecewise polynomial."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "465b8445-1d85-4f9b-849c-731f332aab1f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Let's try a longer range\n",
    "k = 7\n",
    "n = 3\n",
    "num_fit = n*(k-1) + 1\n",
    "x = LinRange(-1, -1+2*n, num_fit)\n",
    "runge(x) = 1 / (1 + 10*x^2)\n",
    "y = runge.(x)\n",
    "scatter(x, y, label=\"data\")\n",
    "\n",
    "# And let's try to fit our piecewise polynomial\n",
    "a, C_piecewise = fit_piecewise_chebyshev(x, y, n, k)\n",
    "\n",
    "# And a global fit\n",
    "c_global = inv(vander_chebyshev(x)) * y\n",
    "\n",
    "# Finally, let's use that fit\n",
    "k = 50\n",
    "x = LinRange(-1, -1+2*n, n*(k-1) + 1)\n",
    "\n",
    "## Here's the true function\n",
    "y_true = runge.(x)\n",
    "plot!(x, y_true, label=\"true\")\n",
    "\n",
    "## The piecewise fit\n",
    "y_piecewise = interpolate_piecewise_chebyshev(x, a, C_piecewise, n, k)\n",
    "@show norm(y_true - y_piecewise)\n",
    "plot!(x, y_piecewise, label=\"fit, piecewise\")\n",
    "\n",
    "## And the global fit\n",
    "y_global = vander_chebyshev(x, num_fit) * c_global\n",
    "@show norm(y_true - y_global);\n",
    "plot!(x, y_global, label=\"fit, global\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d219684d-a86e-4d10-bc93-9b0f26c32e78",
   "metadata": {},
   "source": [
    "Previously, we repaired this Runge phenomenon by selecting better interpolation points.\n",
    "\n",
    "We will try this again here by using a cosine range on each subinterval.\n",
    "Fill in the function below so that our points $x$ use the `CosRange` distribution on each subinterval."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6bf84c7f-088f-443f-a479-b5bf38c0e9c2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Here's our CosRange function\n",
    "CosRange(a, b, n) = (a + b)/2 .+ (b - a)/2 * cos.(LinRange(-pi, 0, n))\n",
    "\n",
    "# And a piecewise range utility\n",
    "function build_range(a, b, n, k, range_function)\n",
    "    \"\"\"Return a range of points for a piecewise interpolation on the interval [a, b].\n",
    "    There will be n subintervals with k points on each subinterval.\n",
    "    `range_function` is the function used to distribute points on one of the subintervals.\n",
    "    \"\"\"\n",
    "    w  = (b - a) / n # Size of the subinterval\n",
    "    x1 = range_function(a, a + w, k)\n",
    "    x  = zeros(n*(k - 1) + 1)\n",
    "    for j = 1:n\n",
    "        ### BEGIN SOLUTION\n",
    "\n",
    "        ### END SOLUTION\n",
    "    end\n",
    "    x\n",
    "end\n",
    "\n",
    "# And our true data to fit\n",
    "k = 7\n",
    "n = 3\n",
    "num_fit = n*(k-1) + 1\n",
    "x = build_range(-1, -1 + 2*n, n, k, CosRange)\n",
    "y = runge.(x)\n",
    "scatter(x, y, label=\"data\")\n",
    "\n",
    "# And let's try to fit our piecewise polynomial\n",
    "a, C_piecewise = fit_piecewise_chebyshev(x, y, n, k)\n",
    "\n",
    "# And a global fit\n",
    "c_global = inv(vander_chebyshev(x)) * y\n",
    "\n",
    "# Finally, let's use that fit\n",
    "k = 50\n",
    "x = LinRange(-1, -1+2*n, n*(k-1) + 1)\n",
    "\n",
    "## Here's the true function\n",
    "y_true = runge.(x)\n",
    "plot!(x, y_true, label=\"true\")\n",
    "\n",
    "## The piecewise fit\n",
    "y_piecewise = interpolate_piecewise_chebyshev(x, a, C_piecewise, n, k)\n",
    "@show norm(y_true - y_piecewise)\n",
    "plot!(x, y_piecewise, label=\"fit, piecewise\")\n",
    "\n",
    "## And the global fit\n",
    "y_global = vander_chebyshev(x, num_fit) * c_global\n",
    "@show norm(y_true - y_global);\n",
    "plot!(x, y_global, label=\"fit, global\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9b466c0a-1e3d-4d2f-8f7f-7b2bde22593e",
   "metadata": {},
   "source": [
    "Discuss the tradeoffs between using global and piecewise polynomial interpolation.\n",
    "Include any additional charts with other functions, numbers of subintervals ($n$), and number of points per subinterval ($k$) to support your discussion."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6b0abcff-73f4-452c-90e0-093591a405ea",
   "metadata": {},
   "source": [
    "### BEGIN SOLUTION\n",
    "\n",
    "### END SOLUTION"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "36cf822e-dd49-4bcb-9867-c495cc15e045",
   "metadata": {},
   "source": [
    "## Integration\n",
    "\n",
    "One important use of interpolation is integration.\n",
    "We have the polynomial\n",
    "\n",
    "$$ p \\left( x \\right) = \\sum_{i = 0}^n c_i T_i \\left( x \\right)$$\n",
    "\n",
    "for the Chebyshev polynomials\n",
    "\n",
    "$$ \\begin{align}\n",
    "  T_0 \\left( x \\right) &= 1\\\\\n",
    "  T_1 \\left( x \\right) &= x\\\\\n",
    "  T_n \\left( x \\right) &= 2 x T_{n - 1} \\left( x \\right) - T_{n - 2} \\left( x \\right)\n",
    "\\end{align} $$\n",
    "\n",
    "Suppose we wanted to compute the integral \n",
    "\n",
    "$$ \\int_a^b p \\left( x \\right) \\, dx = \\int_a^b \\sum_{i = 0}^n c_i T_i \\left( x \\right) \\, dx $$\n",
    "\n",
    "Using the powers of alegbraic simplification, we can instead compute\n",
    "\n",
    "$$ \\int_a^b p \\left( x \\right) \\, dx = \\sum_{i = 0}^n c_i \\int_a^b T_i \\left( x \\right) \\, dx $$\n",
    "\n",
    "This feels like something we can get traction with, especially with the [special properties](https://en.wikipedia.org/wiki/Chebyshev_polynomials) of the Chebyshev polynomials.\n",
    "\n",
    "$$ \\begin{align}\n",
    "  \\int_a^b T_0 \\left( x \\right) &= \\left. x \\right\\vert_a^b\\\\\n",
    "  \\int_a^b T_1 \\left( x \\right) &= \\left. \\frac{1}{2} x^2 \\right\\vert_a^b\\\\\n",
    "  \\int_a^b T_n \\left( x \\right) &= \\left. \\frac{1}{2} \\left( \\frac{T_{n + 1} \\left( x \\right)}{n + 1} - \\frac{T_{n - 1} \\left( x \\right)}{n - 1} \\right) \\right\\vert_a^b\n",
    "\\end{align} $$\n",
    "\n",
    "where\n",
    "\n",
    "$$ \\left. f \\left( x \\right) \\right\\vert_a^b = f \\left( b \\right) - f \\left( a \\right) $$\n",
    "\n",
    "We can use this recursion to turn our interpolation coefficients into integration coefficients."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8f2f2d3f-94ef-46e2-b5ae-72bec7f37cf9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to get Chebyshev polynomial integrals\n",
    "function chebyshev_integrals(k)\n",
    "    \"\"\"Return the values of the integrals of the Chebyshev polynomials on the interval [-1, 1].\n",
    "    \"\"\"\n",
    "    T_a = zeros(k+1)\n",
    "    T_b = zeros(k+1)\n",
    "    # Initalize\n",
    "    a = -1\n",
    "    b = 1\n",
    "    T_a[1] = 1 # Note that T_a[1] is T_0\n",
    "    T_a[2] = a\n",
    "    T_b[1] = 1\n",
    "    T_b[2] = b\n",
    "    # Follow the Chebyshev polynomial recursion to compute T_n\n",
    "    for i = 3:k+1\n",
    "        ### BEGIN SOLUTION\n",
    "\n",
    "        ### END SOLUTION\n",
    "    end\n",
    "    # And now compute the integrals\n",
    "    interp_T = zeros(k)\n",
    "    interp_T[1] = b - a\n",
    "    interp_T[2] = (1/2) * b^2 - (1/2) * a^2\n",
    "    for i = 3:k\n",
    "        # NOTE: Be careful with indexing here!\n",
    "        # Julia uses 1 based indexing but the math equations use 0 based indexing!!\n",
    "        ### BEGIN SOLUTION\n",
    "\n",
    "        ### END SOLUTION    \n",
    "    end\n",
    "    interp_T'\n",
    "end\n",
    "\n",
    "# Let's try it\n",
    "a = -1\n",
    "b = 1\n",
    "k = 5\n",
    "x = LinRange(a, b, k)\n",
    "y = x.^4 # We should be able to exactly integrate this!\n",
    "p = scatter(x, y, label=\"true\")\n",
    "A = vander_chebyshev(x)\n",
    "\n",
    "# Fit the Chebyshev polynomials\n",
    "c = inv(A) * y\n",
    "x_plt = LinRange(a, b, 100)\n",
    "p = plot!(x_plt, vander_chebyshev(x_plt, k) * c, label=\"fit\")\n",
    "display(p)\n",
    "\n",
    "# Integrate the fit polynomial\n",
    "interp_T = chebyshev_integrals(k)\n",
    "@show interp_T * c ≈ (1/5) * b^5 - (1/5) * a^5;"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "76908924-c9c0-41a6-8871-eca52cd392c4",
   "metadata": {},
   "source": [
    "## Piecewise polynomial integration\n",
    "\n",
    "And now we can combine these two ideas.\n",
    "Complete the function below to compute an integral of a piecewise polynomial fit."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "17407ec4-045d-4675-ac48-8a0b09e2b182",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Integrate using piecewise Chebyshev polynomials\n",
    "function integrate_piecewise_chebyshev(x, y, n, k)\n",
    "    \"\"\"Return the value of integrating a piecewise fit of Chebyshev polynomials on the interval x for the values y.\n",
    "    n is a parameter stating how many subintervals there are.\n",
    "    k is a parameter stating how many points are on each subinterval.\n",
    "    This function returns the integral of the piecewise Chebyshev polynomial interpolation.\n",
    "    \"\"\"\n",
    "    # Get fit\n",
    "    a, C = fit_piecewise_chebyshev(x, y, n, k)\n",
    "    # Build our integral values\n",
    "    w = (x[end] - x[1]) / n\n",
    "    interp_T  = chebyshev_integrals(k)\n",
    "    interp_T *= (w / 2) # Why do I need this line?\n",
    "    # And a place to hold output\n",
    "    interp = 0\n",
    "    for j in 1:n\n",
    "        # Sum up the integrals on each interval\n",
    "        ### BEGIN SOLUTION\n",
    "\n",
    "        ### END SOLUTION\n",
    "    end\n",
    "    interp\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "76acb282-2c71-4c5d-a3b0-0e5c45d9cb3e",
   "metadata": {},
   "source": [
    "Let's use our new function to compute the integral\n",
    "\n",
    "$$ \\int_0^5 cos \\left( x \\right) \\, dx $$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7f6f3134-44d6-4337-b6a4-1fc048079328",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Let's integrate cosine with increasingly many subintervals and points\n",
    "plot()\n",
    "a = 0\n",
    "b = 5\n",
    "max_n = 5\n",
    "max_k = 5\n",
    "for n in 1:max_n # number of subintervals\n",
    "    println(\"---- $n subintervals ----\")\n",
    "    for k in 2:max_k # number of points per subinterval\n",
    "        x = build_range(a, b, n, k, LinRange)\n",
    "        y = cos.(x)\n",
    "        # Interpolate the fit\n",
    "        a, C = fit_piecewise_chebyshev(x, y, n, k)\n",
    "        # Integrate the fit\n",
    "        integral = integrate_piecewise_chebyshev(x, y, n, k)\n",
    "        # Plot the fix\n",
    "        x = build_range(a, b, n, 100, LinRange)\n",
    "        y = interpolate_piecewise_chebyshev(x, a, C, n, 100)\n",
    "        if k == max_k\n",
    "            plot!(x, y, label=\"n = $n, k = $k\")\n",
    "        end\n",
    "        # And print out info\n",
    "        println(\"$k points each, integral ≈ $integral\")\n",
    "    end\n",
    "    println()\n",
    "end\n",
    "\n",
    "# And the true fit\n",
    "println(\"---- true value ----\")\n",
    "@show sin(b) - sin(a)\n",
    "x = LinRange(a, b, 300)\n",
    "y = cos.(x)\n",
    "p = plot!(x, y, color=:black, label=\"true\");"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c7b95755-c74f-4daa-86a1-1491c475b750",
   "metadata": {},
   "outputs": [],
   "source": [
    "display(p)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e82f1757-a333-400c-8b4e-8508f4eb5e5d",
   "metadata": {},
   "source": [
    "## Exploration\n",
    "\n",
    "1) Run some experiments using different values of $n$ and $k$ and using `LinRange` and `CosRange` for our integration example above.\n",
    "Generate a plot summarizing your results and discuss your plot."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b7ce681b-3a03-4873-ba1e-3a81cc9b3d54",
   "metadata": {},
   "outputs": [],
   "source": [
    "### BEGIN SOLUTION\n",
    "\n",
    "### END SOLUTION"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "317b30c3-80e3-4d83-b673-29da7d819088",
   "metadata": {},
   "source": [
    "2) This technique can exactly integrate polynomials up to degree $k - 1$.\n",
    "If we correctly select the location of the integration points, then we can see accurate integration for polynomials of up to degree $2k - 1$.\n",
    "This is known as [Gaussian quadrature](https://en.wikipedia.org/wiki/Gaussian_quadrature).\n",
    "Discuss the pros and cons of this approach vs the one in this assignment."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b7b0f9f4-5ab1-4396-b1ad-f78b83c4ab45",
   "metadata": {},
   "outputs": [],
   "source": [
    "### BEGIN SOLUTION\n",
    "\n",
    "### END SOLUTION"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd011b85-e55b-4122-8e45-b498acfb2c67",
   "metadata": {},
   "source": [
    "3) Select a Julia package that implements numerical integration.\n",
    "Use the package for a few integrals.\n",
    "Discuss the ease of use and quality of documentation for the package you picked."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "019b33c7-e962-4e8c-a705-f683a9432132",
   "metadata": {},
   "outputs": [],
   "source": [
    "### BEGIN SOLUTION\n",
    "\n",
    "### END SOLUTION"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Julia 1.11.6",
   "language": "julia",
   "name": "julia-1.11"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.11.6"
  },
  "nbsphinx": {
   "execute": "never"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
