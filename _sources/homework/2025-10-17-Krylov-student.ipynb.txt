{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "f70d5620-d299-4228-9ad9-201e46d94188",
   "metadata": {},
   "source": [
    "Before you turn this problem in, make sure everything runs as expected.\n",
    "First, restart the kernel (in the menubar, select Kernel → Restart) and then run all cells (in the menubar, select Cell → Run All).\n",
    "\n",
    "Make sure you fill in any place that says `BEGIN SOLUTION` and `END SOLUTION`, as well as your name and collaborators below:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cc75c0c6-6bb8-4420-9a3a-f4ccd8cfccc7",
   "metadata": {},
   "outputs": [],
   "source": [
    "NAME = \"\"\n",
    "COLLABORATORS = \"\""
   ]
  },
  {
   "cell_type": "markdown",
   "id": "854915ed-f28e-4b74-a715-5b513c8e5ef2",
   "metadata": {},
   "source": [
    "# 2025-10-17 Krylov Subspaces\n",
    "\n",
    "In class, we discussed computing the $QR$ factorization of a matrix by applying an orthogonalization process, such as Gram-Schmidt to the columns of a matrix $A$.\n",
    "However, this can become impractical if the matrix $A$ is quite large, such as linear systems of equations representing billions of unknown values in a large scale computational simulation.\n",
    "\n",
    "There exists a family of iterative methods based upon the **Krylov subspace**.\n",
    "In this assignment, we will look at one of these **Krylov subspace** methods, the **conjugate gradient** method.\n",
    "\n",
    "Suppose the matrix $A$ is square.\n",
    "The [**Krylov subspace**](https://en.wikipedia.org/wiki/Krylov_subspace) generated by the $n \\times n$ matrix $A$ and the vector $b$ of length $n$ is defined as the linear subspace of the images of $b$ under the first $k + 1$ powers of $A$.\n",
    "That is to say,\n",
    "\n",
    "$$ \\mathscr{K}_r \\left( A, b \\right) = \\text{span} \\left\\lbrace b, A b, A^2 b, \\dots, A^k b \\right\\rbrace $$"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "02fc86d2-017b-443f-a969-aaa3cc976f7d",
   "metadata": {},
   "source": [
    "## Building a Krylov subspace\n",
    "\n",
    "Let's start by comparing a Krylov subspace and the columns of a $QR$ factorization for the Vandermonde matrix."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aa51d100-347a-41d5-b4f1-de136ac737fb",
   "metadata": {},
   "outputs": [],
   "source": [
    "using LinearAlgebra\n",
    "using Plots\n",
    "using Test\n",
    "\n",
    "# Here's our Vandermonde matrix again\n",
    "function vander(x, k=nothing)\n",
    "    \"\"\"Return a Vandermonde matrix of the first k monomials evaluated at the points x.\n",
    "    The returned matrix will be of size m x k, where m is the length of the vector x.\n",
    "    If no k is provided, the returned matrix will be square.\n",
    "    \"\"\"\n",
    "    if isnothing(k)\n",
    "        k = length(x)\n",
    "    end\n",
    "    m = length(x)\n",
    "    V = ones(m, k)\n",
    "    for j in 2:k\n",
    "        V[:, j] = V[:, j-1] .* x\n",
    "    end\n",
    "    V\n",
    "end"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "413403dc-2f2c-4077-b3bd-45d856817bef",
   "metadata": {},
   "source": [
    "We'll use this convenience function for visualizing the difference between the basis formed from the columns of $A$ with $QR$ factorization and the Krylov basis we'll form below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dd76241e-f631-43f0-a659-330c29431520",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Helper function to plot the columns of a matrix as basis functions\n",
    "\n",
    "function plot_basis(x, A)\n",
    "    \"\"\"Plot a series of basis vectors stored in the columns of the matrix A\n",
    "    at the points given by x. The length of x and the number of rows of A\n",
    "    must be the same.\n",
    "    \"\"\"\n",
    "    _, m = size(A)\n",
    "    plt = plot(x, A[:, 1], label=\"\\$q_0\\$\")\n",
    "    for i in 2:m\n",
    "        plt = plot!(x, A[:, i], label=\"\\$q_$(i-1)\\$\")\n",
    "    end\n",
    "    display(plt)\n",
    "end\n",
    "\n",
    "# Plot the basis vectors from a QR factorization of the Vandermonde matrix\n",
    "n = 15\n",
    "x = LinRange(-1, 1, n)\n",
    "Q, R = qr(vander(x))\n",
    "plot_basis(x, Q[:, 1:4])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c64f30a5-2125-4598-a0db-6e8b1f748a05",
   "metadata": {},
   "source": [
    "Krylov subspace methods are iterative methods used to solve linear systems of equations $A x = b$.\n",
    "For now, we will focus on creating the Krylov subspace of degree $k$ for the matrix $A$.\n",
    "\n",
    "The Krylov subspace is formed by the vectors\n",
    "\n",
    "$$ \\mathscr{K}_r \\left( A, b \\right) = \\text{span} \\left\\lbrace b, A b, A^2 b, \\dots, A^k b \\right\\rbrace $$\n",
    "\n",
    "However, we want an orthonormal basis.\n",
    "We will use [**Gram-Schmidt orthogonalization**](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process) as part of the [**Arnoldi iteration**](https://en.wikipedia.org/wiki/Arnoldi_iteration) to form this orthonormal basis.\n",
    "\n",
    "That is to say, we will form the matrices $Q$ and $H$ such that\n",
    "\n",
    "* $Q$ is $n \\times k + 1$ with the orthonormalized columns given by the Gram-Schmidt process on the vectors $A^i b$\n",
    "\n",
    "* $H$ is the $k \\times k$ [**upper Hessenberg**](https://en.wikipedia.org/wiki/Hessenberg_matrix) matrix holding the factors from the Gram-Schmidt process.\n",
    "\n",
    "This definition of $H$ may seem strange, however it has a powerful application.\n",
    "The matrix $H$ is constructed so that $H =  Q^T A Q$.\n",
    "This means that $A Q_n = Q_{n + 1} \\tilde{H}_n$, where $Q_n$ is the orthonormal basis of the Krylov subspace with $n$ vectors (columns) while $Q_{n + 1}$ is the basis of the Krylov subspace with $n + 1$ vectors and $\\tilde{H}_n$ is augmented with an additional row.\n",
    "\n",
    "Our function will return the matrix $\\tilde{H}$ which is the $k + 1 \\times k$ matrix holding the factors $\\tilde{H}_{i, j-1} = q_i \\cdot v$ from the Gram-Schmidt process on and above the diagonal and the norms $\\tilde{H}_{i, i-1} = \\lvert \\lvert v \\rvert \\rvert$ on the lower subdiagonal."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e3ded457-856c-441d-95a0-45216bb71d16",
   "metadata": {},
   "outputs": [],
   "source": [
    "function arnoldi(A, b, k=nothing)\n",
    "    \"\"\"Form the Krylov subspace from the initial vector b and the matrix A.\n",
    "    This function returns a pair of matrices Q, H.\n",
    "    The columns of Q are the orthonormalized basis vectors for the Krylov space.\n",
    "    H is upper Hessenberg and holds the normalization factors.\n",
    "    \"\"\"\n",
    "    # Get our dimensions for the subspace\n",
    "    n, _ = size(A)\n",
    "    if isnothing(k)\n",
    "        k = n\n",
    "    end\n",
    "    # Build a matrix to hold the subspace and initialize it\n",
    "    Q = zeros(n, k+1)\n",
    "    # Let's put our factors here, similar to QR\n",
    "    H = zeros(k+1, k)\n",
    "    r = norm(b)\n",
    "    Q[:, 1] = b / r\n",
    "    for i in 2:k+1\n",
    "        v = A * Q[:, i-1]\n",
    "        for j in 1:i\n",
    "            ### BEGIN SOLUTION]\n",
    "\n",
    "            ### END SOLUTION\n",
    "        end\n",
    "        r = norm(v)\n",
    "        # We need to stop if the norm of v is small\n",
    "        #  This means v ≈ 0\n",
    "        if r < 1e3 * eps()\n",
    "            break\n",
    "        end\n",
    "        Q[:, i] = v / r\n",
    "        H[i, i-1] = r\n",
    "    end\n",
    "    Q, H\n",
    "end\n",
    "\n",
    "# And let's look at what happens\n",
    "n = 4\n",
    "x = LinRange(-1, 1, n) # Need a square matrix\n",
    "Q, H = arnoldi(vander(x), ones(n), 4)\n",
    "@show Q[:, 1]\n",
    "@show Q[:, 2]\n",
    "println(\"H =\")\n",
    "display(H);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e515328a-aad3-4092-b7f4-3aeb51bf19b7",
   "metadata": {},
   "outputs": [],
   "source": [
    "A = [2 1 0; 1 3 0; 0 0 4]\n",
    "b = [1 1 1]\n",
    "Q, H = arnoldi(A, b)\n",
    "\n",
    "@test Q[:, end] ≈ zeros(3)\n",
    "@test Q * Q' ≈ I\n",
    "@test A * Q[:, 1:end-1] ≈ Q * H"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "025c52da-9902-4e38-89a8-87649e5b511e",
   "metadata": {},
   "source": [
    "Let's plot the basis vectors from our Arnoldi iterations and see how they compare to the basis vectors from the $QR$ factorization."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d217c9bb-aeb5-42e6-a7be-d5f0bb66f3e7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Plot the basis vectors from the Arnoldi iterations for a Vandermonde matrix\n",
    "n = 15\n",
    "x = LinRange(-1, 1, n)\n",
    "Q, H = arnoldi(vander(x), ones(n), 3)\n",
    "plot_basis(x, Q)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a9f47062-9d05-4b20-b12d-11872cbd7a4e",
   "metadata": {},
   "source": [
    "This plot looks significantly different, telling us that we cannot interpret this basis in the same way as we did before.\n",
    "However, we can use the basis from the Arnoldi iteration to solve a linear system of equations $A x = b$.\n",
    "We'll come back to this, but first let's pick a problem to solve.\n",
    "\n",
    "We will solve the equation $A p = y$, where $A$ is the Vandermonde matrix at some points $x$ and $p$ represents the polynomial coefficients for the polynomial of degree $3$ that fits the points $(x_i, y_i)$ given by the vectors $x$ and $y$.\n",
    "\n",
    "First, let's solve a system of equations with $QR$ factorization as we did in class.\n",
    "With $QR$ factorization, we form the orthonormal matrix $Q$ and the upper triangular matrix $R$ such that $A = QR$.\n",
    "This means that $Q R p = y$ or $p = R^{-1} Q^{-1} y_1$.\n",
    "Since $Q$ is orthonormal, $Q^{-1} = Q^T$.\n",
    "$R$ is upper triangular and can be solved algorithmically.\n",
    "\n",
    "Complete the function below to solve a system of equations $R x = b$, where $R$ is a upper triangular matrix."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0f641a46-fceb-485c-b92b-f7b1359d68e4",
   "metadata": {},
   "outputs": [],
   "source": [
    "function solve_upper_triangular(R, b)\n",
    "    \"\"\"Solve the linear system of equations R x = b.\n",
    "    R is upper triangular.\n",
    "    This function returns the vector x such that R x = b.\n",
    "    \"\"\"\n",
    "    # We'll store the solution in x\n",
    "    n, _ = size(R)\n",
    "    x = zeros(n)\n",
    "    # And solve for each x_i starting with the last row\n",
    "    for i in n:-1:1 # Note the syntax here, how does i increment?\n",
    "        x_i = b[i]\n",
    "        # Solve the equation R_(i, :) * x_i = b_i for the current row\n",
    "        ### BEGIN SOLUTION\n",
    "\n",
    "        ### END SOLUTION\n",
    "        x[i] = x_i / R[i, i]\n",
    "    end\n",
    "    x\n",
    "end\n",
    "\n",
    "# Let's do a small test\n",
    "R = [1. 2 3;\n",
    "     0  4 5;\n",
    "     0  0 6]\n",
    "b = [1.; 1; 1]\n",
    "@show x = solve_upper_triangular(R, b)\n",
    "@show R * x - b;"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a879d529-c400-4868-95c9-af31ba814e30",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 'normal' test case\n",
    "R = [1. 2 3 4 5;\n",
    "     0  6 7 8 9;\n",
    "     0  0 8 7 6;\n",
    "     0  0 0 5 4;\n",
    "     0  0 0 0 3]\n",
    "b = [1.; 2; 3; 4; 5]\n",
    "x = solve_upper_triangular(R, b)\n",
    "@test R * x - b ≈ zeros(5)\n",
    "\n",
    "# and a trivial test case\n",
    "R = [1. 0;\n",
    "     0  1]\n",
    "b = [1.; 2]\n",
    "x = solve_upper_triangular(R, b)\n",
    "@test R * x - b ≈ zeros(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1d80f355-8928-48df-b1f1-bfc30079930e",
   "metadata": {},
   "source": [
    "Now we can your function `solve_upper_triangular()` to solve the linear system of equations $A p = y_1$ given below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "99db81b0-23e0-4bb0-b2d2-f8ea84848acf",
   "metadata": {},
   "outputs": [],
   "source": [
    "# We want A p = y1\n",
    "# Note - using x1 and y1 to distinguish from the plotting points x below\n",
    "x1 = [-0.9, 0.1,  0.5, 0.8]\n",
    "y1 = [ 1.0, 2.4, -0.2, 1.3]\n",
    "A = vander(x1)\n",
    "\n",
    "# Form the basis of A via QR factorization and solve for p\n",
    "Q, R = qr(A)\n",
    "p = solve_upper_triangular(R, Q' * y1)\n",
    "@show p_qr = p\n",
    "\n",
    "# And plot\n",
    "k = 4\n",
    "n = 50\n",
    "x = LinRange(-1, 1, n)\n",
    "scatter(x1, y1, label=\"data\")\n",
    "plot!(x, vander(x, k) * p, label=\"\\$p = R^{-1} Q^T b\\$\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dbf61c71-2db0-4d82-bf0e-c1a0d25a6b81",
   "metadata": {},
   "source": [
    "We can also use the Krylov subspace from our Arnoldi iteration to solve a linear system of equations $A x = b$.\n",
    "There are several Krylov subspace methods that have been developed; however we will use the [**Generalized minimal residual method**](https://en.wikipedia.org/wiki/Generalized_minimal_residual_method) (GMRES).\n",
    "\n",
    "Given the basis $Q_n$ from the Arnoldi process, we want to find the coefficients $c$ to form the nearest vector in the Krylov subspace to the solution, which is the vector $x_n = x_0 + Q_n c_n$ such that the residual\n",
    "$\\left\\lvert \\left\\lvert r_n \\right\\rvert \\right\\rvert = \\left\\lvert \\left\\lvert b - A x_n \\right\\rvert \\right\\rvert$ is minimized.\n",
    "For simplicity, we will use $x_0 = 0$.\n",
    "\n",
    "Simplifying our expression, we have\n",
    "\n",
    "$$ \\begin{align}\n",
    "    \\left\\lvert \\left\\lvert r_n \\right\\rvert \\right\\rvert\n",
    "    &= \\left\\lvert \\left\\lvert b - A x_n \\right\\rvert \\right\\rvert\\\\\n",
    "    &= \\left\\lvert \\left\\lvert b - A Q_n c_n \\right\\rvert \\right\\rvert\\\\\n",
    "    &= \\left\\lvert \\left\\lvert b - Q_{n + 1} \\tilde{H}_n c_n \\right\\rvert \\right\\rvert\\\\\n",
    "    &= \\left\\lvert \\left\\lvert Q_{n + 1} \\left( \\beta e_1 - \\tilde{H}_n c_n \\right) \\right\\rvert \\right\\rvert\\\\\n",
    "\\end{align} $$\n",
    "\n",
    "where $\\beta = \\left\\lvert \\left\\lvert b  \\right\\rvert \\right\\rvert\\\\$ and $e_1 = \\left[ 1, 0, 0, \\dots, 0 \\right]$.\n",
    "\n",
    "We therefore want to find the solution to the least squares problem $\\beta e_1 - \\tilde{H}_n c_n = 0$.\n",
    "We can then use our vector $c_n$ to form $x_n = x_0 + Q_n c_n = Q_n c_n$ (because we assumed $x_0 = 0$).\n",
    "\n",
    "Note that we could create a function `solve_upper_hessenberg()`, but we will forgo that detail and focus on using our Krylov subspace.\n",
    "We can use `\\` to let Julia solve this system of equations for us."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1232863a-4978-4add-b95f-3dc3a1352347",
   "metadata": {},
   "outputs": [],
   "source": [
    "# We want A p = y1\n",
    "# Again using x1 and y1 to distinguish x1 from the plotting points x below\n",
    "x1 = [-0.9, 0.1,  0.5, 0.8]\n",
    "y1 = [ 1.0, 2.4, -0.2, 1.3]\n",
    "A = vander(x1)\n",
    "\n",
    "# Form the Krylov subspace\n",
    "k = 4\n",
    "Q, H = arnoldi(A, y1, k)\n",
    "\n",
    "# Solve the least squares problem\n",
    "β = norm(y1)\n",
    "e1 = zeros(k+1)\n",
    "e1[1] = 1\n",
    "### BEGIN SOLUTION\n",
    "\n",
    "### END SOLUTION\n",
    "p = Q[:, 1:k] * c\n",
    "@show p_gmres = p\n",
    "@show norm(p_gmres - p_qr)\n",
    "\n",
    "# And plot\n",
    "n = 50\n",
    "x = LinRange(-1, 1, n)\n",
    "scatter(x1, y1, label=\"data\")\n",
    "plot!(x, vander(x, k) * p, label=\"\\$p = Q H^{-1} e_1\\$\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0f36501e-3e76-4e9d-b683-acbfdfb12c13",
   "metadata": {},
   "source": [
    "It should reassure us greatly that we appear to have reached the same solution.\n",
    "\n",
    "It may seem like we did a more work to set up a problem that is more difficult to solve than using the $QR$ factorization.\n",
    "While this may be true for small systems of equations, the true power of Krylov subspace methods is the fact that it they are iterative methods.\n",
    "This offers two important benefits.\n",
    "\n",
    "* For large systems of equations (millions or billions of values in the solution vector), we do not need to form the entire full rank Krylov space to achieve a solution $x_n$ with a low residual $r_n$.\n",
    "\n",
    "* The assembled matrix $A$ is not required, only the ability to apply the matrix-vector product $A x$. This enables [**matrix-free methods**](https://en.wikipedia.org/wiki/Matrix-free_methods) and [**Newton-Krylov methods**](https://en.wikipedia.org/wiki/Newton%E2%80%93Krylov_method), which are workhorses in large scale computational simulations, such as on supercomputers.\n",
    "\n",
    "Let's implement the ability to expand our Krylov subspace so we can see the benefit of the first point."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fb87d935-2c0a-42e3-bc52-b0d8852dc9dd",
   "metadata": {},
   "outputs": [],
   "source": [
    "function arnoldi_update(A, Q, H)\n",
    "    \"\"\"Update the Krylov subspace from the initial vector b and the matrix A.\n",
    "    This function returns an updated pair of matrices Q, H.\n",
    "    Q has a new column for the next orthonormal vector and H has the updated factors.\n",
    "    \"\"\"\n",
    "    # Get our dimensions for the subspace\n",
    "    n, k = size(Q)\n",
    "    # Build a new Q\n",
    "    # This is inefficient but shows the idea\n",
    "    Q_new = zeros(n, k+1)\n",
    "    Q_new[:, 1:k] = Q\n",
    "    # And a new H\n",
    "    H_new = zeros(k+1, k)\n",
    "    H_new[1:k, 1:k-1] = H\n",
    "    # Compute new Krylov vector\n",
    "    v = A * Q_new[:, k]\n",
    "    for j in 1:k\n",
    "        ### BEGIN SOLUTION]\n",
    "\n",
    "        ### END SOLUTION\n",
    "    end\n",
    "    r = norm(v)\n",
    "    # We need to stop if the norm of v is small\n",
    "    #  This means v ≈ 0\n",
    "    if r > 1e3 * eps()\n",
    "        Q_new[:, k+1] = v / r\n",
    "        H_new[k+1, k] = r\n",
    "    end\n",
    "    Q_new, H_new\n",
    "end\n",
    "\n",
    "# And let's look at what happens\n",
    "n = 4\n",
    "x = LinRange(-1, 1, n) # Need a square matrix\n",
    "A = vander(x)\n",
    "b = ones(n)\n",
    "\n",
    "# Let's compare the old\n",
    "Q, H = arnoldi(A, b, 4)\n",
    "println(\"arnoldi(A, b, 4)\")\n",
    "@show Q[:, 4]\n",
    "println(\"H =\")\n",
    "display(H);\n",
    "\n",
    "# With the new\n",
    "Q, H = arnoldi(A, ones(n), 3)\n",
    "Q, H = arnoldi_update(A, Q, H)\n",
    "println(\"\\narnoldi(A, b, 3) and arnoldi_update(A, Q, H)\")\n",
    "@show Q[:, 4]\n",
    "println(\"H =\")\n",
    "display(H);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "18492801-cbdc-43b8-85da-a421154b01b5",
   "metadata": {},
   "outputs": [],
   "source": [
    "A = [2 1 0; 1 3 0; 0 0 4]\n",
    "b = [1 1 1]\n",
    "\n",
    "Q, H = arnoldi(A, b, 2)\n",
    "Q, H = arnoldi_update(A, Q, H)\n",
    "\n",
    "@test Q[:, end] ≈ zeros(3)\n",
    "@test Q * Q' ≈ I\n",
    "@test A * Q[:, 1:end-1] ≈ Q * H"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "286947a6-5c91-42a5-9302-504f3a8956ff",
   "metadata": {},
   "source": [
    "We can use our iterative updates above to provide refined solutions to our problem $A x = b$ until we hit a target tolerance.\n",
    "In the code below, fill in the missing pieces to see the convergence of GMRES as we try to fit a polynomial to datapoints from the function $f \\left( x \\right) = \\sin \\left( \\pi x \\right) e^x$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5c04b127-7a1e-4e4f-96a8-0f487eed4a59",
   "metadata": {},
   "outputs": [],
   "source": [
    "# We want A p = y1\n",
    "# Again using x1 and y1 to distinguish x1 from the plotting points x below\n",
    "k_max = 65\n",
    "x1 = [0.0, -0.0243502926634244, 0.0243502926634244, -0.072993121787799, 0.072993121787799, -0.121462819296121, 0.121462819296121, -0.169644420423993, 0.169644420423993, -0.217423643740007, 0.217423643740007, -0.264687162208767, 0.264687162208767, -0.311322871990211, 0.311322871990211, -0.357220158337668, 0.357220158337668, -0.402270157963992, 0.402270157963992, -0.446366017253464, 0.446366017253464, -0.489403145707053, 0.489403145707053, -0.531279464019895, 0.531279464019895, -0.571895646202634, 0.571895646202634, -0.611155355172393, 0.611155355172393, -0.648965471254657, 0.648965471254657, -0.685236313054233, 0.685236313054233, -0.719881850171611, 0.719881850171611, -0.752819907260532, 0.752819907260532, -0.783972358943341, 0.783972358943341, -0.813265315122798, 0.813265315122798, -0.84062929625258, 0.84062929625258, -0.865999398154093, 0.865999398154093, -0.889315445995114, 0.889315445995114, -0.910522137078503, 0.910522137078503, -0.92956917213194, 0.92956917213194, -0.946411374858403, 0.946411374858403, -0.961008799652054, 0.961008799652054, -0.973326827789911, 0.973326827789911, -0.983336253884626, 0.983336253884626, -0.991013371476744, 0.991013371476744, -0.996340116771955, 0.996340116771955, -0.999305041735772, 0.999305041735772]\n",
    "y1 = sin.(π * x1) .* exp.(x1)\n",
    "A = vander(x1)\n",
    "n = 50\n",
    "x_plt = LinRange(-1, 1, n)\n",
    "A_plt = vander(x_plt, k_max)\n",
    "plt = scatter(x1, y1, label=\"data\")\n",
    "\n",
    "# Form the initial Krylov subspace\n",
    "k = 1\n",
    "Q, H = arnoldi(A, y1, k)\n",
    "\n",
    "# Solve the least squares problem\n",
    "β = norm(y1)\n",
    "e1 = zeros(k+1)\n",
    "e1[1] = 1\n",
    "### BEGIN SOLUTION\n",
    "\n",
    "### END SOLUTION\n",
    "pn = Q[:, 1:k] * c\n",
    "plt = plot!(x_plt, A_plt * pn, label=\"\\$k = 1\\$\")\n",
    "\n",
    "# And let's track the norm of the residuals\n",
    "r = zeros(k_max)\n",
    "r[k] = norm(y1 - A * pn)\n",
    "\n",
    "# And see how well our solution matches as we increase k\n",
    "for k = 2:k_max\n",
    "    # Update the Krylov subspace\n",
    "    Q, H = arnoldi_update(A, Q, H)\n",
    "\n",
    "    # Solve the least squares problem\n",
    "    β = norm(y1)\n",
    "    e1 = zeros(k+1)\n",
    "    e1[1] = 1\n",
    "    ### BEGIN SOLUTION\n",
    "\n",
    "    ### END SOLUTION\n",
    "    pn = Q[:, 1:k] * c\n",
    "    if k % 16 == 1\n",
    "        plt = plot!(x_plt, A_plt * pn, label=\"\\$k = $k\\$\")\n",
    "    end\n",
    "\n",
    "    # And calculate the latest residual\n",
    "    r[k] = norm(y1 - A * pn)\n",
    "end\n",
    "display(plt)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2eb93458-8f7f-443f-8c30-2732d2083f83",
   "metadata": {},
   "source": [
    "Finally, let's look at the residual $b - A x_n$ (in this case $y - A p_n$) as the number of vectors in our Krylov subspace increases.\n",
    "We are often interested in the normalized residual, so normalize by $\\left\\lvert \\left\\lvert b \\right\\rvert \\right\\rvert$ and plot the residuals on a log-linear scale (log scale in $y$, linear scale in $x$).\n",
    "\n",
    "Discuss the convergence.\n",
    "Is there a value $n < 65$ for which the solution $x_n$ might be acceptable?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5944b103-6c80-47f1-b476-33108ce24ff2",
   "metadata": {},
   "outputs": [],
   "source": [
    "### BEGIN SOLUTION\n",
    "\n",
    "### END SOLUTION"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "169ee5cb-f0f6-4cde-a990-5fae25431507",
   "metadata": {},
   "source": [
    "### BEGIN SOLUTION\n",
    "\n",
    "### END SOLUTION"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b805c681-0cdc-43c1-ac9e-7949c8c7281f",
   "metadata": {},
   "source": [
    "## Exploration\n",
    "\n",
    "Select at least one of these exploration problems.\n",
    "\n",
    "1) GMRES is not the only Krylov subspace method.\n",
    "Select another Krylov subspace method, such as Conjugate Gradient, and compare it with GMRES.\n",
    "Compare the assumptions required for the matrix $A$ (symmetric, positive definite, etc), defining any relevant terms.\n",
    "Discuss the trade-offs between GMRES and the method you picked.\n",
    "Provide links to at least 2 sources you found (yes, one can be Wikipedia!).\n",
    "\n",
    "2) Select a software package that uses Krylov methods.\n",
    "Provide a link to this package.\n",
    "Summarize which Krylov methods this package uses.\n",
    "Try to determine why the developers picked the Krylov method they did."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ab7976cb-b24a-4953-8078-7642077b0570",
   "metadata": {},
   "source": [
    "## Exploration 1\n",
    "\n",
    "### BEGIN SOLUTION\n",
    "\n",
    "### END SOLUTION"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7fbb124a-cf32-4ae8-b465-233c1f5a1060",
   "metadata": {},
   "source": [
    "## Exploration 2\n",
    "\n",
    "### BEGIN SOLUTION\n",
    "\n",
    "### END SOLUTION"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Julia 1.11.6",
   "language": "julia",
   "name": "julia-1.11"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.11.6"
  },
  "nbsphinx": {
   "execute": "never"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
